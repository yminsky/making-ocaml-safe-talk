#+TITLE: Making OCaml Safe for Performance Engineering

* Making OCaml Safe for Performance Engineering

* What is OCaml like?

** Expressive static type system, w/type inference

     #+BEGIN_SRC ocaml
     let rec map l f =
        match l with
        | [] -> []
        | first :: rest -> f first :: map rest f
     #+END_SRC

   will have its type inferred as:

     #+BEGIN_SRC ocaml
     val map : 'a list -> ('a -> 'b) -> 'b list
     #+END_SRC

** Simple, pervasive polymorphism

   #+BEGIN_SRC ocaml
   val map : 'a list -> ('a -> 'b) -> 'b list
   #+END_SRC

** Simple representation of OCaml values

  - Either *immediate* or *block*

  - *immediates* fit inside a machine word, minus tag bit
    - Examples: int, char, bool

  - *blocks* are heap-allocated values
    - one header word
    - one word per nested value
    - Examples: string, array, record

  - Polymorphism and separate compilation are built on this.
** Parallelism

- Pre 5.0: no parallelism
  - A single GIL (like Python)

- 5.0 and beyond: Multicore GC
  - with sane memory model
  - but no reliable way to avoid races

* What's not to love?

** Minimal control over memory representation

  - hard to keep data compact
    - byte has an overhead of 8x
    - even int64 has an overhead of 3x!
  - pointer indirection defeats prefetcher
  - heap allocation is inefficient

** Unsafe parallelism is no fun

  - Even with a good memory model,
    it's incredibly error-prone
  - and good memory models are expensive!

* What do we want?

  *Safe* and *convenient* control
  over performance-critical aspects of program behavior,
  but *only where you need it*.

  And...in OCaml! So the changes must be *conservative*.

* What we're building

Three major user-facing features:

- Narrow and flat data layouts
- Stack allocation
- Parallel programming

Built on two new type-system features:

  *kinds* and *modes*

* Narrow and flat data layout

** Unboxed Types

Have to escape OCaml's "value" representation!

But this breaks polymorphism!

  - Categorize types by their *layout*
    - which is itself a kind
  - polymorphism is limited by kind

    # TODO: Add a code example or two.
** What layouts are there?

  - Regular values
    - #value, #immediate

  - Narrow atomic layouts
    - #bit16, #bits8, #bits0, #float

  - Nestable, structured types
    - #{ foo: #bits8; bar: int list }

** How are unboxed types used?

- On their own, admit no heap representation
- So, how to use them?
  - can be passed to and returned from functions
  - can be packed into heap-allocated values
  - can be arranged in unboxed arrays
  - can be mapped back-and-forth to boxed equivalents
  - boxed equivalents can be mutated

** Clawing polymorphism back

- Lack of polymorphism is really a pain
- But, don't need to write the code multiple times!
- Can write once, instantiate once per kind

* Stack allocation

** Heap vs Stack allocation

Heap allocation is expensive

  - Major heap allocation is very expensive
  - Even minor heap allocation is cache-inefficent

Stack allocation is better!

  - Similar to minor-heap allocation
  - But values are collected faster, cheaper
  - Touch fewer cache lines

** Making stack allocation safe

  - Follow a *stack discipline*
  - Mainly:
    - don't create pointers from heap to stack
    - don't return stack values

** Can't we Rust?

Why not use Rust-style lifetimes?

- Functions take (often implicit) *lifetime* parameter
- Values under polymorphic lifetimes can be stack-allocated

But,

- You often trip in to higher-order polymorphism
- Inference is undecidable!
- Very un-ocaml, and arguably unergonomic

** Instead, Modes!

Modes are:

- Properties that can be applied to any type
- That by default apply deeply

In this case, we add a pair of modes:

- *global* is the default, unconstrained
- *local* values must follow the stack discipline

There's sub-moding:

  - can pass a local where a global is expected

** Example

If type of List.map is:

#+BEGIN_SRC ocaml
val map : 'a list -> ('a -> 'b) -> 'b list
        @ .       -> local      -> .
#+END_SRC

then this doesn't allocate:

#+BEGIN_SRC ocaml
let multiply_by l mult =
  List.map l (fun x -> mult * x)
#+END_SRC

# TODO: Make sure this signature is correct!


** Lots more to do!

- Support mode-polymorphism
- Integrate modes and kinds
  - Who cares if your immediate is local?
  - always(m) is a kind that tracks this

** Smart constructors

functions that can return local values, e.g.:

    #+BEGIN_SRC ocaml
    type pos = { x: float; y: float }
    let create_pos x y = local { x; y }

    val create_local_pos
      : float -> float -> pos
      @ local -> local -> local
    #+END_SRC

- Local-returning fxns don't create their own stack frame

* Data-race freedom

** Modes are a natural fit

Things you can do to any value:

- Make an alias
- Return from a function
- Create a pointer to it
- Pass to another thread

These operations are all *deep*.

Modes are a natural match to control these!
And just what we need for controlling parallelism

** A bestiary of modes

12 modes, in 5 dimensions.

| dimension     |             |           |          |
|---------------+-------------+-----------+----------|
| Locality      | local       |           | _global_ |
| Aliasing      | unique      | exclusive | _shared_ |
| Linearity     | _many_      | separate  | once     |
| Read/write    | _readwrite_ |           | readonly |
| Parallel-safe | sync        |           | _unsync_ |

** Examples

- spawn
- lock and key
