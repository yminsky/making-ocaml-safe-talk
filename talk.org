#+TITLE: Making OCaml Safe for Performance Engineering

* Making OCaml Safe for Performance Engineering

* What is OCaml like?

** Expressive static type system, w/type inference

     #+BEGIN_SRC ocaml
     let rec map l f =
        match l with
        | [] -> []
        | first :: rest -> f first :: map rest f
     #+END_SRC

   will have its type inferred as:

     #+BEGIN_SRC ocaml
     val map : 'a list -> ('a -> 'b) -> 'b list
     #+END_SRC

** Simple, pervasive polymorphism

   #+BEGIN_SRC ocaml
   val map : 'a list -> ('a -> 'b) -> 'b list
   #+END_SRC

** Simple representation of OCaml values

  - Either *immediate* or *block*

  - *immediates* fit inside a machine word, minus tag bit
    - Examples: int, char, bool

  - *blocks* are heap-allocated values
    - one header word
    - one word per nested value
    - Examples: string, array, record

  - Polymorphism and separate compilation are built on this.
** Parallelism

- Pre 5.0: no parallelism
  - A single GIL (like Python)

- 5.0 and beyond: Multicore GC
  - with sane memory model
  - but no reliable way to avoid races

* What's not to love?

** Minimal control over memory representation

  - hard to keep data compact
    - byte has an overhead of 8x
    - even int64 has an overhead of 3x!
  - pointer indirection defeats prefetcher
  - heap allocation is inefficient

** Unsafe parallelism is no fun

  - Even with a good memory model,
    it's incredibly error-prone
  - and good memory models are expensive!

* What do we want?

  *Safe* and *convenient* control
  over performance-critical aspects of program behavior,
  but *only where you need it*.

  And...in OCaml! So the changes must be *conservative*.

* What we're building

Three major user-facing features:

- Narrow and flat data layouts
- Stack allocation
- Parallel programming

Built on two new type-system features:

  *kinds* and *modes*

* Narrow and flat data layout

** Unboxed Types

Have to escape OCaml's "value" representation.

A bunch of new types!

- Unboxed primitives
    #int32, #int8, #float
- Unboxed records
    #{ foo: #int32; bar: int list }

How to work with these?

- No don't heap representation
- Can be passed and returned as extra arguments
- Can be boxed, or placed in arrays

# TODO: Add a code example or two.

** What about polymorphism?

But this breaks polymorphism!

  - Categorize types by their *layout*
    - which is itself a kind
  - polymorphism is limited by kind

** What layouts are there?

  - Regular values
    - value, immediate

  - Narrow atomic layouts
    - #bits32, #bits8, #void, #float

  - Aggregated layouts
    - #bits32 * #bits8 * #float

** How are unboxed types used?

- On their own, admit no heap representation
- So, how to use them?
  - can be passed to and returned from functions
  - can be packed into heap-allocated values
  - can be arranged in unboxed arrays
  - can be mapped back-and-forth to boxed equivalents
  - boxed equivalents can be mutated

** Clawing polymorphism back

- Lack of polymorphism is really a pain
- But, don't need to write the code multiple times!
- Can write once, instantiate once per kind

* Stack allocation

** Heap vs Stack allocation

Heap allocation is expensive

  - Major heap allocation is very expensive
  - Even minor heap allocation is cache-inefficent

Stack allocation is better!

  - Similar to minor-heap allocation
  - But values are collected faster, cheaper
  - Touch fewer cache lines

** Making stack allocation safe

  - Follow a *stack discipline*
  - Mainly:
    - don't create pointers from heap to stack
    - don't return stack values

** Can't we Rust?

Why not use Rust-style lifetimes?

- Functions take (often implicit) *lifetime* parameter
- Values under polymorphic lifetimes can be stack-allocated

But,

- You often trip in to higher-order polymorphism
- Inference is undecidable!
- Very un-ocaml, and arguably unergonomic

** Instead, Modes!

Modes are:

- Properties that can be applied to any type
- That by default apply deeply

** Global and Local

In this case, we add a pair of modes:

- *global* is the default, unconstrained
- *local* values must follow the stack discipline

There's sub-moding:

  - can pass a local where a global is expected

** Stack allocation

If type of List.map is:

#+BEGIN_SRC ocaml
val map : 'a list -> ('a -> 'b) -> 'b list
        @ .       -> local      -> .
#+END_SRC

then this doesn't allocate:

#+BEGIN_SRC ocaml
let multiply_by l mult =
  List.map l (fun x -> mult * x)
#+END_SRC

# TODO: Make sure this signature is correct!

** Smart constructors

functions that can return local values, e.g.:

    #+BEGIN_SRC ocaml
    type pos = { x: float; y: float }
    let create_pos x y = local { x; y }

    val create_local_pos
      : float -> float -> pos
      @ local -> local -> local
    #+END_SRC

Local-returning fxns don't create their own stack frame

** Resource allocation

#+BEGIN_SRC ocaml
val with_file
  : string -> (In_channel.t -> 'a) -> 'a
  @ .      -> (local        ->  .) ->  .
#+END_SRC

** Lots more to do!

- Support mode-polymorphism

   TODO: better example for mode polymorphism?

   #+BEGIN_SRC ocaml
   val map
     : 'a list ->       ('a -> 'b) -> 'b list
     @ 'm      -> local ('m -> 'n) -> 'n
   #+END_SRC


- Integrate modes and kinds
  - Who cares if your immediate is local?
  - always(m) is a kind that tracks this

- Other applications of local, like typed effects!

* Data-race freedom

** Modes are a natural fit

Things you can do to any value:

- Make an alias
- Return from a function
- Create a pointer to it
- Pass to another thread

These operations are all *deep*.

Modes are a natural match to control these!
And just what we need for controlling parallelism

** A new mode dimension: thread-safety

Values can be *sync* or *unsync*.

- *sync* values can safely be accessed concurrently
- *unsync* has no such guarantee

So, what's sync?

- All deeply immutable values are sync by default.
- Synchronization primitives can be sync too

** A bestiary of modes

12 modes, in 5 dimensions.

| dimension     |          |           |             |
|---------------+----------+-----------+-------------|
| Locality      | local    |           | *global*    |
| Thread-safety | *unsync* |           | sync        |
| Aliasing      | *shared* | exclusive | unique      |
| Linearity     | once     | separate  | *many*      |
| Readonly      | readonly |           | *readwrite* |

** Spawning threads

- fxn run by thread must be sync
- returned value doesn't have to be

#+BEGIN_SRC ocaml
val spawn
  :      (unit -> 'a) -> 'a thread
  @ sync (.    ->  .) ->  .

val join
  : 'a thread -> 'a
  @ .         ->  .
#+END_SRC

** Communicating via channels

Data sent between threads must by sync.

#+BEGIN_SRC ocaml
val send
  : 'a channel -> 'a   -> unit
  @ .          -> sync -> .

val recv
  : 'a channel -> 'a
  @ .          -> sync
#+END_SRC


* State of the work

- stack allocation is in production
- Kinds are in progress
- Data-race freedom is still being designed

All available on github.

* Challenges

- Lots of internal iteration on design
-
