#+TITLE: Making OCaml Safe for Performance Engineering

Abstract:

    Over the last couple of years, Jane Street has greatly increased
    its investment in OCaml, and has started developing major
    extensions to the OCaml's type system, with the primary goal of
    making OCaml a better language for writing high-performance
    systems.

    In this talk, I'll attempt to provide a developer's-eye view of
    these changes.  We'll cover two major directions of innovation:
    first, the addition of modal types to OCaml, which opens up a
    variety of ambitious features, like memory-safe stack-allocation;
    type-level tracking of effects, and data-race freedom guarantees
    for multicore code.  The second is the addition of a kind system
    to OCaml, which will provides more control over the representation
    of memory, in particular allowing for structured data to be
    represented in a cache-and-prefetch-friendly tabular form.
    Together, these features pull together some of the most important
    features for writing high performance code in Rust, while
    maintaining the relative simplicity of programming in OCaml.

    In all of this, I'll focus less on the type theory, and more on
    how these features are surfaced to users, the practical problems
    that they help us solve, and the place in the design space of
    programming languages that this leaves us in.



* Making OCaml Safe for Performance Engineering

  A 50,000-foot view of changes Jane Street is working on
  to make OCaml into a better language for performance engineering
* What is OCaml like?

** Expressive static type system, w/type inference

     #+BEGIN_SRC ocaml
     let rec map l ~f =
        match l with
        | [] -> []
        | first :: rest -> f first :: map rest ~f
     #+END_SRC

   # pause
   will have its type inferred as:

     #+BEGIN_SRC ocaml
     val map : 'a list -> f:('a -> 'b) -> 'b list
     #+END_SRC

   # pause
   Polymorphism is simple and pervasive!

** Implementing polymorphism

  But how can we implement polymorphism in machine code?

  - Example: ints and records have different sizes/shapes
      How can one (machine) function manipulate both types?

  - One possible solution: C++ generics
      Compiler makes copies of each generic function

  - OCaml has a different solution!

** Uniform representation of values

  Either *immediate* or *block*

  # pause
  *immediates* fit inside a machine word, minus tag bit
    Examples: int, char, bool

  # pause
  *blocks* are heap-allocated values
    one header word
    one word per nested value
    Examples: string, array, record

  # pause
  Also important for GC
** Fast separate compilation

  - Importantly, compile once for all types
  - Depends on uniform memory representation

** Parallelism

# pause
Pre 5.0: no parallelism
  A global runtime lock (like Python)

# pause
5.0 and beyond: Multicore GC
  with sane memory model
  but no race-free programming model

* So, what's not to love?

** Minimal control over memory representation

  - hard to keep data compact
    - byte takes 8 bytes
    - int64 (8 bytes) takes 24!
  - pointer indirection defeats prefetcher
  - All non-trivial data must be exposed to GC
** Unsafe parallelism is no fun

  - Even with a good memory model,
    it's incredibly error-prone
  - and good memory models are expensive!

* Design goals

  # pause
  *Safe*, *convenient*, *predictable* control
  over performance-critical aspects of program behavior,
  # pause
  but *only where you need it*.

  # pause
  And...in OCaml!
  So changes must be *backwards-compatible*.

* What we're building

Three major user-facing features:

- Narrow and flat data layouts
- Stack allocation
- Race-free parallel programming

All type-safe, built on two type-system features:

# pause
  *kinds* and *modes*

* Narrow and flat data layout

** Unboxed Types

New types with different representations!

# pause
Unboxed primitives
  int32#, int8#, float#

# pause
Can fit within ordinary types
  { foo: int8#; bar: int32# }

# pause
And unboxed records
  #{ foo: int8#; bar: int list }

# pause
And arrays of unboxed records
   #{ foo: int8#; bar: int32# } array

** What can you do with them?

- Unboxed types have no heap representation, but:
- can be passed to functions (as multiple args)
- returned from functions (multi-argument return)
- placed within heap-allocated values
  - and then mutated


** What about polymorphism?

But this breaks polymorphism!

- Categorize types by their *layout*
  - which is a *kind*
- allow polymorphism up to kind

** What layouts are there?

A lattice of atomic layouts:

                    any
                     |
         -------------------------------
        /      |       |        |   ... \
     value   void   float64   bits8     bits64
       |
 non_null_value

  - any: unknown layout, uses can't be compiled
      Useful in signatures
  - non_null_value: powers non-allocating options
      #+BEGIN_SRC ocaml
      type ('a : non_null_value) or_null
      #+END_SRC

  - Aggregate layouts: bits64 * bits32 * void * bits8

* Stack allocation

** Heap vs Stack allocation

- Heap allocation is expensive
  - Especially major heap allocation
  - Minor is better, but still cache-inefficent

- Stack allocation is better!
  - Similar to minor-heap allocation
  - But values are collected faster, cheaper
  - Touch fewer cache lines

** Making stack allocation safe

  - Follow a *stack discipline*
  - Mainly:
    - don't create pointers from heap to stack
    - don't return stack values

** Can't we Rust?

- Why not use Rust-style lifetimes?

  - Functions take (often implicit) *lifetime* parameter
  - Values under polymorphic lifetimes can be stack-allocated

- But,

  - You often trip in to higher-order polymorphism
  - Inference is undecidable!
  - Very un-ocaml, and arguably unergonomic

** Instead, Modes!

Modes are:

  - Properties that can be applied to any type
  - That by default apply deeply

** Global and Local

# pause
In this case, we add a pair of modes:

   *global* is the default, unconstrained
   *local* values must follow the stack discipline

# pause
There's sub-moding!

  can pass a global where a local is expected

** An example of stack allocation

#+BEGIN_SRC ocaml
let rec map l ~f =
  match l with
  | [] -> []
  | hd :: tl -> f hd :: map tl ~f
#+END_SRC

# pause
#+BEGIN_SRC ocaml
val map : 'a list -> ~f:('a -> 'b) -> 'b list
       @@ .       -> local      -> .
#+END_SRC

# pause
#+BEGIN_SRC ocaml
let multiply_by l mult =
  map l (fun x -> mult * x)
#+END_SRC

** Smart constructors

functions that can return local values if they
don't create a stack frame.

    # pause
    #+BEGIN_SRC ocaml
    type pos = { x: float; y: float }
    let create_pos x y = exclave { x; y }
    #+END_SRC

    # pause
    #+BEGIN_SRC ocaml
    val create_pos
      : float -> float -> pos
     @@ local -> local -> local
    #+END_SRC

** Resource allocation

#+BEGIN_SRC ocaml
val with_file
  : string -> f:(In_channel.t -> 'a) -> 'a
 @@ .      -> (local        ->  .) ->  .
#+END_SRC

** Mode polymorphism

   # pause
Instead of this:

   #+BEGIN_SRC ocaml
   val hd
     : 'a list -> 'a
    @@ .       ->  .

   val hd_local
     : 'a list -> 'a
    @@ local   -> local
   #+END_SRC

   # pause
Write this:

   #+BEGIN_SRC ocaml
   val hd : 'a list -> 'a
         @@ 'm      -> 'm
   #+END_SRC


** Modal kinds

  - Who cares if your immediate is local?
  - always(local) is a kind that tracks this

* Data-race freedom

** Modes are a natural fit

# pause
Things you can do to any value:

- Make an alias
- Return from a function
- Create a pointer to it
- Pass to another thread

These operations are all *deep*.

** A new mode dimension: thread-safety

# pause
Values can be *sync* or *unsync*.

  *sync* values can safely be accessed concurrently
  *unsync* has no such guarantee

# pause
So, what values are sync?

  - All deeply immutable values are sync by default.
  - Data protected under a synchronization primitive can be sync too

** A bestiary of modes

14 modes, in 5 dimensions.

Two varieties of modes:
- *prescriptive*: What you can do with a value in the future
- *descriptive*: What has happened to a value in the past

| dimension  | variety   || min mode    |             | max mode    |
|------------+-----------++-------------+-------------+-------------|
| Locality   | prescribe || *global*    |             | local       |
| Contention | describe  || uncontended | communal    | *contended* |
| Syncness   | prescribe || sync        | cooperative | *unsync*    |
| Aliasing   | describe  || unique      | exclusive   | *shared*    |
| Linearity  | prescribe || *many*      | separate    | once        |

** Spawning threads

- function run by thread must be sync
- returned value doesn't have to be

#+BEGIN_SRC ocaml
val spawn
  :      (unit -> 'a) -> 'a thread
 @@ sync (.    ->  .) ->  .
#+END_SRC

# pause
#+BEGIN_SRC ocaml
val join
  : 'a thread -> 'a
 @@ .         ->  .
#+END_SRC

** Manipulating pointers to shared memory

#+BEGIN_SRC ocaml
module Ptr : sig

  (* A pointer to shared memory holding an ['a], with "key" ['k]. *)
  type ('a, 'k) t

  (* Create a shared memory cell protected by key ['k] *)
  val create : f:(unit -> 'b) -> ('b, 'k) t
            @@ sync           -> .

  (* Manipulate data in shared memory.
     Keys are considered mutable data and can't be used when [contended].
     This ensures data-race freedom. *)
  val map :
      'k Key.t -> f:('a -> 'b) -> ('a, 'k) t -> ('b, 'k) t
   @@ .        -> sync         -> .          -> .

  val extract :
      'k Key.t -> f:('a -> 'b)     -> ('a, 'k) t -> 'b
   @@ .        -> sync (. -> sync) -> .          -> contended

  ...
end
#+END_SRC

* How far are we?

- Stack allocation is in production
- Unboxed types has started to land (float#, unboxed ints out)
    arrays of unboxed primitives is close
- Data-race freedom implementation underway

* So, how's it going?

- Fits into OCaml surprisingly well
- And it makes awkward performance hacks nice!
- Pay-as-you go seems to work
- We're nervous about the complexity!

* More info

- Data-race freedom design doc:
  [[https://github.com/ocaml-flambda/ocaml-jst/blob/main/jane/doc/proposals/data-race-freedom.md]]
- Unboxed types RFC:
  https://github.com/ocaml/RFCs/pull/34
