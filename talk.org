#+TITLE: Making OCaml Safe for Performance Engineering

* Making OCaml Safe for Performance Engineering

  A 50,000-foot view of changes Jane Street is working on
  to make OCaml into a better language for performance engineering
* What is OCaml like?

** Expressive static type system, w/type inference

     #+BEGIN_SRC ocaml
     let rec map l f =
        match l with
        | [] -> []
        | first :: rest -> f first :: map rest f
     #+END_SRC

   # pause
   will have its type inferred as:

     #+BEGIN_SRC ocaml
     val map : 'a list -> ('a -> 'b) -> 'b list
     #+END_SRC

   # pause
   Polymorphism is simple and pervasive!

** Uniform representation of values

  Either *immediate* or *block*

  # pause
  *immediates* fit inside a machine word, minus tag bit
    Examples: int, char, bool

  # pause
  *blocks* are heap-allocated values
    one header word
    one word per nested value
    Examples: string, array, record

  # pause
  Important for GC and polymorphism!
** Fast separate compilation

  - Importantly, compile once for all types
  - Depends on uniform memory representation

** Parallelism

# pause
Pre 5.0: no parallelism
  A global runtime lock (like Python)

# pause
5.0 and beyond: Multicore GC
  with sane memory model
  but no race-free programming model

* So, what's not to love?

** Minimal control over memory representation

  - hard to keep data compact
    - byte takes 8 bytes
    - int64 (8 bytes) takes 24!
  - pointer indirection defeats prefetcher
  - All non-trivial data must be exposed to GC
** Unsafe parallelism is no fun

  - Even with a good memory model,
    it's incredibly error-prone
  - and good memory models are expensive!

* Design goals

  # pause
  *Safe*, *convenient*, *predictable* control
  over performance-critical aspects of program behavior,
  # pause
  but *only where you need it*.

  # pause
  And...in OCaml!
  So changes must be *backwards-compatible*.

* What we're building

Three major user-facing features:

- Narrow and flat data layouts
- Stack allocation
- Race-free parallel programming

All type-safe, built on two type-system features:

# pause
  *kinds* and *modes*

* Narrow and flat data layout

** Unboxed Types

New types with different representations!

# pause
Unboxed primitives
  #int32, #int8, #float

# pause
Can fit within ordinary types
  { foo: #int8; bar: #int32 }

# pause
And unboxed records
  #{ foo: #int8; bar: int list }

# pause
And unboxed arrays!
   #{ foo: #int8; bar: #int32 } array

** What can you do with them?

- Unboxed types have no heap representation, but:
- can be passed to functions (as multiple args)
- returned from functions (multi-argument return)
- placed within heap-allocated values
  - and then mutated


** What about polymorphism?

But this breaks polymorphism!

- Categorize types by their *layout*
  - which is a *kind*
- allow polymorphism up to kind

** What layouts are there?

  - Regular values: value, immediate
  - Atomic layouts: bits32, bits8, void, float
  - Aggregated layouts: bits64 * bits64

# pause
Note the need for sub-kinding!


* Stack allocation

** Heap vs Stack allocation

- Heap allocation is expensive
  - Especially major heap allocation
  - Minor is better, but still cache-inefficent

- Stack allocation is better!
  - Similar to minor-heap allocation
  - But values are collected faster, cheaper
  - Touch fewer cache lines

** Making stack allocation safe

  - Follow a *stack discipline*
  - Mainly:
    - don't create pointers from heap to stack
    - don't return stack values

** Can't we Rust?

- Why not use Rust-style lifetimes?

  - Functions take (often implicit) *lifetime* parameter
  - Values under polymorphic lifetimes can be stack-allocated

- But,

  - You often trip in to higher-order polymorphism
  - Inference is undecidable!
  - Very un-ocaml, and arguably unergonomic

** Instead, Modes!

Modes are:

  - Properties that can be applied to any type
  - That by default apply deeply

** Global and Local

# pause
In this case, we add a pair of modes:

   *global* is the default, unconstrained
   *local* values must follow the stack discipline

# pause
There's sub-moding!

  can pass a global where a local is expected

** An example of stack allocation

#+BEGIN_SRC ocaml
let map l f =
  match l with
  | [] -> []
  | hd :: tl -> f hd :: map tl f
#+END_SRC

# pause
#+BEGIN_SRC ocaml
val map : 'a list -> ('a -> 'b) -> 'b list
        @ .       -> local      -> .
#+END_SRC

# pause
#+BEGIN_SRC ocaml
let multiply_by l mult =
  map l (fun x -> mult * x)
#+END_SRC

** Smart constructors

functions that can return local values if they
don't create a stack frame.

    # pause
    #+BEGIN_SRC ocaml
    type pos = { x: float; y: float }
    let create_pos x y = exclave { x; y }
    #+END_SRC

    # pause
    #+BEGIN_SRC ocaml
    val create_local_pos
      : float -> float -> pos
      @ local -> local -> local
    #+END_SRC

** Resource allocation

#+BEGIN_SRC ocaml
val with_file
  : string -> (In_channel.t -> 'a) -> 'a
  @ .      -> (local        ->  .) ->  .
#+END_SRC

** Mode polymorphism

   # pause
Instead of this:

   #+BEGIN_SRC ocaml
   val hd
     : 'a list -> 'a
     @ .       ->  .

   val hd_local
     : 'a list -> 'a
     @ local   -> local
   #+END_SRC

   # pause
Write this:

   #+BEGIN_SRC ocaml
   val hd : 'a list -> 'a
          @ 'm      -> 'm
   #+END_SRC


** Modal kinds

  - Who cares if your immediate is local?
  - always(local) is a kind that tracks this

* Data-race freedom

** Modes are a natural fit

# pause
Things you can do to any value:

- Make an alias
- Return from a function
- Create a pointer to it
- Pass to another thread

These operations are all *deep*.

** A new mode dimension: thread-safety

# pause
Values can be *sync* or *unsync*.

  *sync* values can safely be accessed concurrently
  *unsync* has no such guarantee

# pause
So, what's sync?

  - All deeply immutable values are sync by default.
  - Data protected under a synchronization primitive can be sync too

** A bestiary of modes

12 modes, in 5 dimensions.

| dimension     |          |           |             |
|---------------+----------+-----------+-------------|
| Locality      | local    |           | *global*    |
| Thread-safety | *unsync* |           | sync        |
| Aliasing      | *shared* | exclusive | unique      |
| Linearity     | once     | separate  | *many*      |
| Readonly      | readonly |           | *readwrite* |

** Spawning threads

- function run by thread must be sync
- returned value doesn't have to be

#+BEGIN_SRC ocaml
val spawn
  :      (unit -> 'a) -> 'a thread
  @ sync (.    ->  .) ->  .
#+END_SRC

# pause
#+BEGIN_SRC ocaml
val join
  : 'a thread -> 'a
  @ .         ->  .
#+END_SRC

** Communicating via channels

Data sent between threads must by sync.

# pause
#+BEGIN_SRC ocaml
val send
  : 'a channel -> 'a   -> unit
  @ .          -> sync -> .
#+END_SRC

# pause
#+BEGIN_SRC ocaml
val recv
  : 'a channel -> 'a
  @ .          -> sync
#+END_SRC

* How far are we?

- stack allocation is in production
- Kinds are in progress
- Data-race freedom is still being designed

* So, how's it going?

- Fits into OCaml surprisingly well
- And it makes awkward performance hacks nice!
- Pay-as-you go seems to work
- We're nervous about the complexity!

* More info

- Data-race freedom design doc:
  [[https://github.com/ocaml-flambda/ocaml-jst/blob/main/jane/doc/proposals/data-race-freedom.md]]
- Unboxed types RFC:
  https://github.com/ocaml/RFCs/pull/34
